var documenterSearchIndex = {"docs":
[{"location":"functions/#Functions-and-Types","page":"Types and Functions","title":"Functions and Types","text":"","category":"section"},{"location":"functions/","page":"Types and Functions","title":"Types and Functions","text":"CurrentModule = FlxQTL","category":"page"},{"location":"functions/#Flexible-Multivariate-Linear-Mixed-Models-(flxMLMM)","page":"Types and Functions","title":"Flexible Multivariate Linear Mixed Models (flxMLMM)","text":"","category":"section"},{"location":"functions/","page":"Types and Functions","title":"Types and Functions","text":"Modules = [FlxQTL, flxMLMM, EcmNestrv]","category":"page"},{"location":"functions/#FlxQTL.FlxQTL","page":"Types and Functions","title":"FlxQTL.FlxQTL","text":"FlxQTL\n\nflexible Multivariate Linear Mixed Model based QTL analysis tools for structured multiple traits.\n\n\n\n\n\n","category":"module"},{"location":"functions/#FlxQTL.flxMLMM","page":"Types and Functions","title":"FlxQTL.flxMLMM","text":"flxMLMM\n\nA module designed for fitting a Multivariate Linear Mixed Model run by Nesterov's Accelerated Gradient  with restarting scheme incorporated with Expectation Conditional Maximization.\n\nThe model:\n\nY=XBZ+R+E, where E(vec(Y))= (Z otimes X)vec(B),  var(vec(Y))= tau^2 K_G otimes K_C + I_n otimes Sigma\n\n\n\n\n\n","category":"module"},{"location":"functions/#FlxQTL.flxMLMM.K2Eig","page":"Types and Functions","title":"FlxQTL.flxMLMM.K2Eig","text":"  K2Eig(Kg,Kc::Array{Float64,2},LOCO::Bool=false)\n\nReturns a two pairs of eigenvectors and eigenvalues for genetic and climatic relatedness matrices.\n\nArguments\n\nKg : A matrix of a genetic kinship, or 3-d array of that if LOCO sets to be true.\nKc : A matrix of a climatic relatedness.\nLOCO : Boolean. Default is false (no LOCO). (Leave One Chromosome Out). LOCO is only connected to the genetic kinship (Kg).\n\nOutput\n\nTg : A matrix of eigenvectors for Kg, or 3-d array of eigenvectors if LOCO sets to be true.\nλg : A vector of eigenvalues for Kg, or matrix of eigenvalues if LOCO sets to be true.\nTc : A matrix of eigenvectors for Kc.\nλc : A vector of eigenvalues for Kc\n\nSee K2eig.\n\nExamples\n\nFor a genetic kinship calculated under LOCO (3-d array of kinship),\n\n Tg,λg,Tc,λc = K2Eig(Kg,Kc,true)\n\n\nproduces a 3-d array of Tg, matrices of λg, Tc, and a vector of λc.\n\n\n\n\n\n","category":"function"},{"location":"functions/#FlxQTL.flxMLMM.K2eig","page":"Types and Functions","title":"FlxQTL.flxMLMM.K2eig","text":"   K2eig(K,LOCO::Bool=false)\n\nReturns eigenvectors and eigenvalues of a (genetic, climatic) relatedness, or 3-d array of these of a genetic relatedness if LOCO is true.\n\nArguments\n\nK : A matrix of (genetic or climatic) relatedness (Default).  3-d array of genetic relatedness (LOCO sets to be true.)\nLOCO : Boolean. Default is false (no LOCO). (Leave One Chromosome Out).\n\nOutput\n\nT : A matrix of eigenvectors, or 3-d array of eigenvectors if LOCO sets to be true.\nλ : A vector of eigenvalues, or matrix of eigenvalues if LOCO sets to be true.\n\nSee also K2Eig.\n\nExamples\n\nFor a (climatic) relatedness, or genetic relatedness for LOCO =false,\n\n T, λ = K2eig(K)\n\n\nproduces a matrix of T and a vector of λ.\n\nFor a genetic kinship calculated under LOCO (3-d array of kinship),\n\n T, λ = K2eig(K,true)\n\n\nproduces a 3-d array of T and a matrix of λ.\n\n\n\n\n\n","category":"function"},{"location":"functions/#FlxQTL.flxMLMM.envScan","page":"Types and Functions","title":"FlxQTL.flxMLMM.envScan","text":"  envScan(Midx::Array{Int64,1},cross::Int64,Tg,Tc::Array{Float64,2},Λg,λc::Array{Float64,1},\n    Y0::Array{Float64,2},XX::Markers,Z0::Array{Float64,2},LOCO::Bool=false;\n            Xnul::Array{Float64,2}=ones(1,size(Y0,2)),itol=1e-4,tol0=1e-3,tol::Float64=1e-4,ρ=0.001)\n\nImplement environment scan conditional on a genetic marker of interest (QTL).  Each of q trait covariate data is scanned (regressed) given a major QTL selected from genome scan, geneScan to obtain LOD scores.\n\nArguments\n\nMidx : A vector of genetic marker indices (major QTL) selected based on LOD scores from geneScan.\ncross : An integer indicating the number of alleles or genotypes. Ex. 2 for RIF, 4 for four-way cross, 8 for HS mouse (allele probabilities), etc.         This value is related to degree of freedom when doing genome scan.\nTg : A n x n matrix of eigenvectors from K2eig, or K2Eig.      Returns 3d-array of eigenvectors as many as Chromosomes if LOCO is true.\nTc : A m x m matrix of eigenvectors from climatic relatedness matrix.\nΛg : A n x 1 vector of eigenvalues from kinship. Returns a matrix of eigenvalues if LOCO is true.\nλc : A m x 1 vector of eigenvalues from climatic relatedness matrix. Use ones(m) for no climatic information added.\nY0 : A m x n matrix of response variables, i.e. m traits (or environments) by n individuals (or lines). For univariate phenotypes, use square brackets in arguement.       i.e. Y0[1,:] (a vector) ->Y[[1],:] (a matrix) .\nXX : A type of Markers.\nZ0 :  A m x q matrix of low-dimensional trait covariate data for environment scan, i.e. minimum or maximum monthly temperature data, monthly photoperiod data, etc.\nLOCO : Boolean. Default is false (no LOCO). Runs genome scan using LOCO (Leave One Chromosome Out).\n\nKeyword Arguments\n\nXnul :  A matrix of covariates. Default is intercepts (1's).  Unless plugging in particular covariates, just leave as it is.\nitol :  A tolerance controlling ECM (Expectation Conditional Maximization) under H0: no QTL. Default is 1e-3.\ntol0 :  A tolerance controlling ECM under H1: existence of QTL. Default is 1e-3.\ntol : A tolerance of controlling Nesterov Acceleration Gradient method under both H0 and H1. Default is 1e-4.\nρ : A tunning parameter controlling tau^2. Default is 0.001.\n\n!!! Note\n\nWhen some LOD scores return negative values, reduce tolerences for ECM to tol0 = 1e-4. It works in most cases. If not,   can reduce both tol0 and tol to 1e-4 or further.\n\nOutput\n\nLODs : A vector of LOD scores by envrionment scan when including each major QTL.\nB : A 3-d array of B (fixed effects) matrices under H1: existence of an environment factor (covariate)        conditional on a major QTL.\nest0 : A type of EcmNestrv.Approx including parameter estimates under H0: no environment factor          conditional on a major QTL.\n\n\n\n\n\n","category":"function"},{"location":"functions/#FlxQTL.flxMLMM.gene2Scan","page":"Types and Functions","title":"FlxQTL.flxMLMM.gene2Scan","text":"gene2Scan(cross::Int64,Tg,Tc::Array{Float64,2},Λg,λc::Array{Float64,1},\n    Y0::Array{Float64,2},XX::Markers,Z0::Array{Float64,2},LOCO::Bool=false;ρ=0.001,Xnul::Array{Float64,2}=ones(1,size(Y0,2))\n    ,itol=1e-4,tol0=1e-3,tol::Float64=1e-4)\ngene2Scan(cross::Int64,Tg,Λg,Y0::Array{Float64,2},XX::Markers,LOCO::Bool=false;\n                  Xnul::Array{Float64,2}=ones(1,size(Y0,2)),itol=1e-4,tol0=1e-3,tol::Float64=1e-4,ρ=0.001)\n\nImplement 2d-genome scan with/without LOCO (Leave One Chromosome Out). Note that the second gene2Scan() is based on a conventional MLMM:\n\nvec(Y) sim MVN((Z otimes X)vec(B) (or XBZ)  K otimes Sigma_1 +I otimes Sigma_2)\n\nwhere K is a genetic kinship, Sigma_1 Sigma_2 are covariance matrices for random and error terms, respectively.  Z can be replaced with an identity matrix.\n\nArguments\n\ncross : An integer indicating the number of alleles or genotypes. Ex. 2 for RIF, 4 for four-way cross, 8 for HS mouse (allele probabilities), etc.         This value is related to degree of freedom when doing genome scan.\nTg : A n x n matrix of eigenvectors from K2eig, or K2Eig.      Returns 3d-array of eigenvectors as many as Chromosomes if LOCO is true.\nTc : A m x m matrix of eigenvectors from climatic relatedness matrix.\nΛg : A n x 1 vector of eigenvalues from kinship. Returns a matrix of eigenvalues if LOCO is true.\nλc : A m x 1 vector of eigenvalues from climatic relatedness matrix. Use ones(m) for no climatic information added.\nY0 : A m x n matrix of response variables, i.e. m traits (or environments) by n individuals (or lines). For univariate phenotypes, use square brackets in arguement.       i.e. Y0[1,:] (a vector) -> Y[[1],:] (a matrix) .\nXX : A type of Markers.\nZ0 :  An optional m x q matrix of low-dimensional phenotypic covariates, i.e. contrasts, basis functions (fourier, wavelet, polynomials, B-splines, etc.).     If nothing to insert in Z0, just insert an identity matrix, Matrix(1.0I,m,m).  m traits x q phenotypic covariates.\nLOCO : Boolean. Default is false (no LOCO). Runs genome scan using LOCO (Leave One Chromosome Out).\n\nKeyword Arguments\n\nXnul :  A matrix of covariates. Default is intercepts (1's).  Unless adding covariates, just leave as it is.  See geneScan.\nitol :  A tolerance controlling ECM (Expectation Conditional Maximization) under H0: no QTL. Default is 1e-3.\ntol0 :  A tolerance controlling ECM under H1: existence of QTL. Default is 1e-3.\ntol : A tolerance of controlling Nesterov Acceleration Gradient method under both H0 and H1. Default is 1e-4.\nρ : A tunning parameter controlling tau^2. Default is 0.001.\n\n!!! Note\n\nWhen some LOD scores return negative values, reduce tolerences for ECM to tol0 = 1e-4. It works in most cases. If not,   can reduce both tol0 and tol to 1e-4 or further.\n\nOutput\n\nLODs : LOD scores. Can change to - log_10P using lod2logP.\nest0 : A type of EcmNestrv.Approx including parameter estimates under H0: no QTL.\n\n\n\n\n\n","category":"function"},{"location":"functions/#FlxQTL.flxMLMM.geneScan","page":"Types and Functions","title":"FlxQTL.flxMLMM.geneScan","text":"geneScan(cross::Int64,Tg,Tc::Array{Float64,2},Λg,λc::Array{Float64,1},Y0::Array{Float64,2},XX::Markers,Z0::Array{Float64,2},LOCO::Bool=false;\n            Xnul::Array{Float64,2}=ones(1,size(Y0,2)),itol=1e-3,tol0=1e-3,tol::Float64=1e-4,ρ=0.001,LogP::Bool=false)\ngeneScan(cross::Int64,Tg,Tc::Array{Float64,2},Λg,λc::Array{Float64,1},Y0::Array{Float64,2},XX::Markers,LOCO::Bool=false;\n            Xnul::Array{Float64,2}=ones(1,size(Y0,2)),itol=1e-3,tol0=1e-3,tol::Float64=1e-4,ρ=0.001,LogP::Bool=false)\ngeneScan(cross::Int64,Tg,Λg,Y0::Array{Float64,2},XX::Markers,LOCO::Bool=false;\n    Xnul::Array{Float64,2}=ones(1,size(Y0,2)),itol=1e-3,tol0=1e-3,tol::Float64=1e-4,ρ=0.001,LogP::Bool=false)\n\nImplement 1d-genome scan with/without LOCO (Leave One Chromosome Out).  Note that the third geneScan() is based on a conventional MLMM:\n\nvec(Y) sim MVN((Z otimes X)vec(B) (or XBZ)  K otimes Sigma_1 +I otimes Sigma_2)\n\nwhere K is a genetic kinship, Sigma_1 Sigma_2 are covariance matrices for random and error terms, respectively.  Z can be replaced with an identity matrix.\n\nArguments\n\ncross : An integer indicating the number of alleles or genotypes. Ex. 2 for RIF, 4 for four-way cross, 8 for HS mouse (allele probabilities), etc.         This value is related to degree of freedom when doing genome scan.\nTg : A n x n matrix of eigenvectors from K2eig, or K2Eig.      Returns 3d-array of eigenvectors as many as Chromosomes if LOCO is true.\nTc : A m x m matrix of eigenvectors from climatic relatedness matrix.\nΛg : A n x 1 vector of eigenvalues from kinship. Returns a matrix of eigenvalues if LOCO is true.\nλc : A m x 1 vector of eigenvalues from climatic relatedness matrix. Use ones(m) for no climatic information added.\nY0 : A m x n matrix of response variables, i.e. m traits (or environments) by n individuals (or lines). For univariate phenotypes, use square brackets in arguement.       i.e. Y0[1,:] (a vector) ->Y[[1],:] (a matrix) .\nXX : A type of Markers.\nZ0 :  An optional m x q matrix of low-dimensional phenotypic covariates, i.e. contrasts, basis functions (fourier, wavelet, polynomials, B-splines, etc.).     If nothing to insert in Z0, just exclude it or insert an identity matrix, Matrix(1.0I,m,m).  m traits x q phenotypic covariates.\nLOCO : Boolean. Default is false (no LOCO). Runs genome scan using LOCO (Leave One Chromosome Out).\n\nKeyword Arguments\n\nXnul :  A matrix of covariates. Default is intercepts (1's): 'Xnul= ones(1,size(Y0)).  Adding covariates (C) isXnul= vcat(ones(1,m),C)' where size(C)=(c,m) for m = size(Y0,1).\nitol :  A tolerance controlling ECM (Expectation Conditional Maximization) under H0: no QTL. Default is 1e-3.\ntol0 :  A tolerance controlling ECM under H1: existence of QTL. Default is 1e-3.\ntol : A tolerance of controlling Nesterov Acceleration Gradient method under both H0 and H1. Default is 1e-4.\nρ : A tunning parameter controlling tau^2. Default is 0.001.\nLogP : Boolean. Default is false.  Returns -log_10P-values instead of LOD scores if true.\n\n!!! Note\n\nWhen some LOD scores return negative values, reduce tolerences for ECM to tol0 = 1e-4. It works in most cases. If not,   can reduce both tol0 and tol to 1e-4 or further.\n\nOutput\n\nLODs (or logP) : LOD scores. Can change to - log_10P-values in lod2logP if LogP = true.\nB : A 3-d array of B (fixed effects) matrices under H1: existence of QTL.  If covariates are added to Xnul : Xnul= [ones(1,size(Y0)); Covariates],       ex. For sex covariates in 4-way cross analysis, B[:,2,100], B[:,3:5,100] are effects for sex, the rest genotypes of the 100th QTL, respectively.\nest0 : A type of EcmNestrv.Approx including parameter estimates under H0: no QTL.\n\n\n\n\n\n","category":"function"},{"location":"functions/#FlxQTL.flxMLMM.permTest-Tuple{Int64, Any, Any, Any, Any, Markers, Any}","page":"Types and Functions","title":"FlxQTL.flxMLMM.permTest","text":"  permTest(nperm,cross,Kg,Kc,Y0,XX::Markers,Z0;pval=[0.05 0.01],Xnul=ones(1,size(Y0,2)),itol=1e-4,tol0=1e-3,tol=1e-4,ρ=0.001)\n  permTest(nperm,cross,Kg,Y0,XX::Markers;pval=[0.05 0.01],Xnul=ones(1,size(Y0,2)),itol=1e-4,tol0=1e-3,tol=1e-4,ρ=0.001)\n\nImplement permutation test to get thresholds at the levels of type 1 error, α.  Note that the second permTest() is for the conventional MLMM: \n\nvec(Y)sim MVN((I otimes X)vec(B) (or BX) K otimes Sigma_1 +I otimes Sigma_2)\n\nwhere K is a genetic kinship, Sigma_1 Sigma_2 are covariance matrices for random and error terms, respectively.\n\nArguments\n\nnperm : An integer indicating the number of permutation to be implemented.\ncross : An integer indicating the number of alleles or genotypes. Ex. 2 for RIF, 4 for four-way cross, 8 for HS mouse (allele probabilities), etc.         This value is related to degree of freedom when doing genome scan.\nKg : A n x n genetic kinship matrix. Should be symmetric positive definite.\nKc : A m x m climatic relatedness matrix. Should be symmetric positive definite.\nY0 : A m x n matrix of response variables, i.e. m traits (or environments) by n individuals (or lines). For univariate phenotypes, use square brackets in arguement.       i.e. Y0[1,:]  (a vector) -> Y[[1],:]  (a matrix) .\nXX : A type of Markers.\nZ0 : An optional m x q matrix of low-dimensional phenotypic covariates, i.e. contrasts, basis functions (fourier, wavelet, polynomials, B-splines, etc.).      If nothing to insert in Z0, just insert an identity matrix, Matrix(1.0I,m,m).  m traits x q phenotypic covariates. \n\nKeyword Arguments\n\npval : A vector of p-values to get their quantiles. Default is [0.05  0.01] (without comma).\nXnul : A matrix of covariates. Default is intercepts (1's).  Unless plugging in particular covariates, just leave as it is.\nitol : A tolerance controlling ECM (Expectation Conditional Maximization) under H0: no QTL. Default is 1e-3.\ntol0 : A tolerance controlling ECM under H1: existence of QTL. Default is 1e-3.\ntol : A tolerance of controlling Nesterov Acceleration Gradient method under both H0 and H1. Default is 1e-4.\nρ : A tunning parameter controlling tau^2. Default is 0.001.  \n\nOutput\n\nmaxLODs : A nperm x 1 vector of maximal LOD scores by permutation. \nH1par_perm : A type of struct, EcmNestrv.Approx(B,τ2,Σ,loglik) including parameter estimates  or EcmNestrv.Result(B,Vc,Σ,loglik)                for a conventional MLMM under H0: no QTL by permutation. \ncutoff : A vector of thresholds corresponding to pval.\n\n\n\n\n\n","category":"method"},{"location":"functions/#FlxQTL.EcmNestrv","page":"Types and Functions","title":"FlxQTL.EcmNestrv","text":"EcmNestrv\n\nA module for base algorithms using ECM (Expectation-Conditional Maxization) with Speed restarting Nesterov's accelerated gradient method  to fit a flexible multivariate linear mixed model (flxMLMM).\n\n\n\n\n\n","category":"module"},{"location":"functions/#Genetic-Relatedness-Matrices-(GRM)","page":"Types and Functions","title":"Genetic Relatedness Matrices (GRM)","text":"","category":"section"},{"location":"functions/","page":"Types and Functions","title":"Types and Functions","text":"Modules = [GRM]","category":"page"},{"location":"functions/#FlxQTL.GRM","page":"Types and Functions","title":"FlxQTL.GRM","text":" GRM\n\nA module for computing Genetic Relatedness Matrix (or kinship).\n\n\n\n\n\n","category":"module"},{"location":"functions/#FlxQTL.GRM.kinship4way-Tuple{Matrix{Float64}}","page":"Types and Functions","title":"FlxQTL.GRM.kinship4way","text":" kinship4way(genmat::Array{Float64,2})\n\nComputes a kinship for four-way cross data counting different alleles between two markers: ex. AB-AB=0; AB-AC=1; AB-CD=2,dots Note: In R/qtl, genotypes are labeled as 1=AC; 2=BC; 3=AD; 4=BD by the function, read.cross.\n\nArgument\n\ngenmat : A matrix of genotypes for four-way cross (12 dots).          size(genematrix)= (p,n), for p genetic markers x n individuals(or lines).\n\nOutput\n\nReturns a n x n symmetric matrix containing 1's on the diagonal.\n\n\n\n\n\n","category":"method"},{"location":"functions/#FlxQTL.GRM.kinshipCtr-Tuple{Matrix{Float64}}","page":"Types and Functions","title":"FlxQTL.GRM.kinshipCtr","text":" kinshipCtr(genmat::Array{Float64,2})\n\nCalculates a kinship by a centered genotype matrix (linear kernel), i.e. genotypes subtracted by marker mean.\n\nArgument\n\ngenmat : A matrix of genotype data (0,1,2). size(genmat)=(p,n) for p markers x n individuals\n\nOutput\n\nReturns a n x n symmetric matrix. See also kinshipStd.\n\n\n\n\n\n","category":"method"},{"location":"functions/#FlxQTL.GRM.kinshipGs-Tuple{Matrix{Float64}, Float64}","page":"Types and Functions","title":"FlxQTL.GRM.kinshipGs","text":" kinshipGs(climate::Array{Float64,2},ρ::Float64)\n\nComputes a kinship matrix using the Gaussian Kernel.\n\nArguments\n\nclimate : A matrix of genotype, or climate information data. size(climate)=(r,m), such that r genotype markers (or days/years of climate factors,           i.e. precipitations, temperatures, etc.), and m individuals (or environments/sites)\nρ : A free parameter determining the width of the kernel. Could be attained empirically.\n\nOutput\n\nReturns a m x m symmetric (positive definite) matrix containing 1's on the diagonal.\n\n\n\n\n\n","category":"method"},{"location":"functions/#FlxQTL.GRM.kinshipLin-Tuple{Any, Any}","page":"Types and Functions","title":"FlxQTL.GRM.kinshipLin","text":"kinshipLin(mat,cross)\n\nCalculates a kinship (or climatic relatedness, kinshipGs) matrix by linear kernel.\n\nArguments\n\nmat : A matrix of genotype (or allele) probabilities usually extracted from R/qtl,       R/qtl2, or the counterpart packages. size(mat)= (p,n) for p genetic markers x n individuals.\ncross : A scalar indicating instances of alleles or genotypes in a genetic marker. ex. 1 for genotypes (labeled as 0,1,2), 2 for RIF, 4 for four-way cross, 8 for HS mouse (allele probabilities), etc.\n\nOutput\n\nReturns a n x n symmetric (positive definite) matrix containing 1's on the diagonal.\n\nSee also kinshipCtr, kinshipStd for genetype data.\n\n\n\n\n\n","category":"method"},{"location":"functions/#FlxQTL.GRM.kinshipLoco","page":"Types and Functions","title":"FlxQTL.GRM.kinshipLoco","text":" kinshipLoco(kin,g::Markers,cross::Int64=1)\n\nGenerates a 3-d array of symmetric positive definite kinship matrices using LOCO (Leave One Chromosome Out) witout shrinkage intensity estimation. When a kinship is not positive definite, a tweak like a weighted average of kinship and Identity is used to correct minuscule negative eigenvalues.\n\nArguments\n\nkin :  A function of computing a kinship. Can only use with kinshipCtr, kinshipStd for genotypes, and with kinshipLin         for genotype (or allele) probabilities.\ng   : A struct of arrays, type  Markers.\ncross :  A scalar indicating instances of alleles or genotypes in a genetic marker.            ex. 1 for genotypes (0,1,2) as default, 2 for RIF, 4 for four-way cross, 8 for HS mouse (allele probabilities), etc.\n\nOutput\n\nReturns 3-d array of n x n symmetric positive definite matrices as many as Chromosomes. Refer to shrinkgLoco.\n\n\n\n\n\n","category":"function"},{"location":"functions/#FlxQTL.GRM.kinshipMan-Tuple{Matrix{Float64}}","page":"Types and Functions","title":"FlxQTL.GRM.kinshipMan","text":"  kinshipMan(genematrix::Array{Float64,2})\n\nCalculates a kinship matrix using a manhattan distance. Missing values need to be either omitted or imputed. This function is for recombinant inbred line (RIL) (AA/BB), not for 4-way cross genotype data.  See kinship4way.\n\nArgument\n\ngenematrix : A matrix of genotypes, i.e. 0,1 (or 1,2).  size(genematrix)= (p,n) for p genetic markers x n individuals(or lines).\n\nOutput\n\nReturns a n x n symmetric matrix containing 1's on the diagonal.\n\n\n\n\n\n","category":"method"},{"location":"functions/#FlxQTL.GRM.kinshipStd-Tuple{Matrix{Float64}}","page":"Types and Functions","title":"FlxQTL.GRM.kinshipStd","text":" kinshipStd(genmat::Array{Float64,2})\n\nCalculates a kinship by a standardized (or normalized) genotype matrix (linear kernel), i.e. genotypes subtracted by marker mean and divided by marker standard deviation. Can also do with climatic information data. See kinshipGs.\n\nArgument\n\ngenmat : A matrix of genotype data (0,1,2). size(genmat)=(p,n) for p markers x n individuals\n\nOutput\n\nReturns a n x n symmetric matrix. See also kinshipCtr.\n\n\n\n\n\n","category":"method"},{"location":"functions/#FlxQTL.GRM.shrinkg-Tuple{Any, Int64, Any}","page":"Types and Functions","title":"FlxQTL.GRM.shrinkg","text":" shrinkg(f,nb::Int64,geno)\n\nEstimates a full-rank positive definite kinship matrix by shrinkage intensity estimation (bootstrap).  Can only use with kinshipMan, kinship4way. This function runs faster by CPU parallelization.  Add workers/processes using addprocs() function before running for speedup.\n\nArguments\n\nf: A function of computing a kinship. Can only use with kinshipMan, kinship4way.\nnb : An integer indicating the number of bootstrap. It does not have to be a large number.\ngeno : A matrix of genotypes. See kinshipMan, kinship4way for dimension.\n\nExample\n\njulia> using flxQTL\njulia> addprocs(8)\njulia> K = shinkage(kinshipMan,20,myGeno)\n\nOutput\n\nReturns a full-rank symmetric positive definite matrix.\n\n\n\n\n\n","category":"method"},{"location":"functions/#FlxQTL.GRM.shrinkgLoco-Tuple{Any, Int64, Markers}","page":"Types and Functions","title":"FlxQTL.GRM.shrinkgLoco","text":"   shrinkgLoco(kin,nb,g::Markers)\n\nGenerates 3-d array of full-rank positive definite kinship matrices by shrinkage intensity estimation (bootstrap) using a LOCO (Leave One Chromosome Out) scheme.\n\nArgument\n\nkin :  A function of computing a kinship. Can only use with kinshipMan, kinship4way\nnb : An integer indicating the number of bootstrap.\ng : A struct of arrays, type Markers.\n\nOutput\n\nReturns 3-d array of n x n symmetric positive definite matrices as many as Chromosomes.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Visualization-(QTLplot)","page":"Types and Functions","title":"Visualization (QTLplot)","text":"","category":"section"},{"location":"functions/","page":"Types and Functions","title":"Types and Functions","text":"Modules = [QTLplot]","category":"page"},{"location":"functions/#FlxQTL.QTLplot","page":"Types and Functions","title":"FlxQTL.QTLplot","text":" QTLplot\n\nA module for generating PyPlot-based 1D-, 2D-plots for LOD scores (or effects).\n\n\n\n\n\n","category":"module"},{"location":"functions/#FlxQTL.QTLplot.layers","page":"Types and Functions","title":"FlxQTL.QTLplot.layers","text":"layers(chr::Array{Any,1},pos::Array{Float64,1},lod::Array{Float64,2})\n\nCreates a struct of arrays for plotting LOD scores, (or main, interaction) effects\n\nArgument\n\nchr : A vector of strings or numbers indicating Chromosome names, ex. 1,2,3,... or 1K,1N,2K,2N,...\npos : A vector of marker positions.\nlod : A matrix of LOD scores obtained from 1d- or 2d-genome scan.  Can be a matrix of effects (main, or interaction).\n\n\n\n\n\n","category":"type"},{"location":"functions/#FlxQTL.QTLplot.plot1d-Tuple{layers}","page":"Types and Functions","title":"FlxQTL.QTLplot.plot1d","text":"  function plot1d(xx::layers;title= \" \",title_font=25,ylabel=\"LOD\",yint=[],yint_color=[\"red\"],Legend=[],fontsize=20,loc=\"upper right\")\n\nGenerates one or more graphs of LOD scores (or effects) obtained from 1d-genome scan on a single plot.\n\nArguments\n\nxx : A type of layers that consists of chromosome names, marker positions, and a matrix of LODs(or effects).\n\nKeyword arguements\n\ntitle : A string of title. Default is blank.\ntitle_font : A string or number to set title fontsize (default= 25). i.e. \"small\", \"medium\", \"large\", or any integer.\nylabel : A string of a y-axis label (default = LOD)\nyint :  A vector of y-intercept(s).\nyint_color : A vector of colors (strings) of y-intercepts in yint.\nLegend : A vector of graph names in layers.\nfontsize : A string or number to set fontsizes of Legend, xlabel and ylabel (default= 20).               i.e. \"small\", \"medium\", \"large\", or any integer.\nloc : A string of Legend's position. Default is \"upper right\".\n\n\n\n\n\n","category":"method"},{"location":"functions/#FlxQTL.QTLplot.plot2d-Tuple{layers}","page":"Types and Functions","title":"FlxQTL.QTLplot.plot2d","text":"    plot2d(S::layers;title_font=20,fontsize=15)\n\nGenerates 2-d heatmap plots of LOD scores from 2d-genome scan\n\nArgument\n\nS: a type of 'layers' that consists of chromosome names, marker positions, and a matrix of LODs\n\nKeyword arguements\n\ntitle_font : A string or number to set title fontsize (default= 20). i.e. \"small\", \"medium\", \"large\", or any integer.\nfontsize : A string or number to set fontsizes of x-, y-ticks, and colorbar (default= 15).               i.e. \"small\", \"medium\", \"large\", or any integer.\n\n\n\n\n\n","category":"method"},{"location":"functions/#FlxQTL.QTLplot.subplot2d-Tuple{layers, Int64}","page":"Types and Functions","title":"FlxQTL.QTLplot.subplot2d","text":" subplot2d(S::layers,sub_dim::Int64;title_font=20,fontsize=15)\n\nGenerates a matrix of 2-d heatmap subplots for LOD scores obtained from 2d-genome scan  \n\nArguments\n\nsub_dim: A two digit integer, where the first digit (m) is the number of rows, the second (n) the number of columns.             It returns a m x n matrix of subplots.\n\nKeyword Arguments\n\ntitle_font : A string or number to set title fontsize (default= 20). i.e. \"small\", \"medium\", \"large\", or any integer.\nfontsize : A string or number to set fontsizes of x-, y-ticks, and colorbar (default= 15).               i.e. \"small\", \"medium\", \"large\", or any integer.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Multivariate-Linear-Models-(MLM)","page":"Types and Functions","title":"Multivariate Linear Models (MLM)","text":"","category":"section"},{"location":"functions/","page":"Types and Functions","title":"Types and Functions","text":"Modules = [MLM]","category":"page"},{"location":"functions/#FlxQTL.MLM","page":"Types and Functions","title":"FlxQTL.MLM","text":"  MLM\n\nA module for fitting general Multivariate Linear Models motivated by functional data analysis via mle or reml. The default fitting method is mle. ( i.e. reml=false)\n\nThe model:  Y=XBZ+E, where E(Y)=XBZ (or E(vec(Y))= (Z otimes X)vec(B) ),  var(vec(E))=Sigma otimes I size(Y)=(n,m), size(X)=(n,p), size(Z)=(m,q).\n\n\n\n\n\n","category":"module"},{"location":"functions/#FlxQTL.MLM.Estimat","page":"Types and Functions","title":"FlxQTL.MLM.Estimat","text":" Estimat(B::Array{Float64,2},Σ::Array{Float64,2},loglik::Float64)\n\nA struct of arrays for results by fitting a multivariate linear model,  mGLM().   The results are B(fixed effects), Σ (m x m covariance matrix), loglik(a value of log-likelihood by mle or reml).\n\n\n\n\n\n","category":"type"},{"location":"functions/#FlxQTL.MLM.mGLM","page":"Types and Functions","title":"FlxQTL.MLM.mGLM","text":"  mGLM(Y::Array{Float64,2},X::Array{Float64,2},Z::Array{Float64,2},reml::Bool=false)\n  mGLM(Y::Array{Float64,2},X::Array{Float64,2},reml::Bool=false)\n\nFitting multivariate General Linear Models via MLE (or REML) and returns a type of a struct Estimat.  \n\nArguments\n\nY : A matrix of response variables, i.e. traits. size(Y)=(n,m) for n individuals x m traits\nX : A matrix of independent variables, i.e. genotypes or genotype probabilities including intercept or/and covariates. size(X)=(n,p) for n individuals x p markers      including intercept or/and covariates \nZ : An optional matrix of low-dimensional phenotypic covariates, i.e. contrasts, basis functions (fourier, wavelet, polynomials, B-splines, etc.).      If nothing to insert in Z, just exclude it or insert Matrix(1.0I,m,m). size(Z)=(m,q) for m traits x q phenotypic covariates.\nreml : Boolean. Default is fitting the model via mle. Resitricted MLE is implemented if true. \n\nOutput\n\nReturns Estimat .\n\n\n\n\n\n","category":"function"},{"location":"functions/#Utility-Functions-(Util)","page":"Types and Functions","title":"Utility Functions (Util)","text":"","category":"section"},{"location":"functions/","page":"Types and Functions","title":"Types and Functions","text":"Modules = [Util]","category":"page"},{"location":"functions/#FlxQTL.Util","page":"Types and Functions","title":"FlxQTL.Util","text":" Util\n\nA module for utility functions.\n\n\n\n\n\n","category":"module"},{"location":"functions/#FlxQTL.Util.Markers","page":"Types and Functions","title":"FlxQTL.Util.Markers","text":"Markers(name::Array{String,1},chr::Array{Any,1},pos::Array{Float64,1},X::Array{Float64,2})\n\nA struct of arrays creating genotype or genotype probability data for genome scan.\n\nArguments\n\nname : A vector of marker names\nchr  : A vector of Chromosomes\npos  : A vector of marker positions (cM)\nX : A matrix of genotypes or genotype probabilities\n\n\n\n\n\n","category":"type"},{"location":"functions/#FlxQTL.Util.Y_huber-Tuple{Matrix{Float64}}","page":"Types and Functions","title":"FlxQTL.Util.Y_huber","text":"Y_huber(Y::Array{Float64,2})\n\nRescale Y (phenotype or trait data) to be less sensitive to outliers using by Huber loss function and MAD (median absolute deviation).  size(Y)=(m,n) for m trait and n individuals.\n\n\n\n\n\n","category":"method"},{"location":"functions/#FlxQTL.Util.array2mat-Tuple{Int64, Array{Float64, 3}}","page":"Types and Functions","title":"FlxQTL.Util.array2mat","text":" array2mat(cross::Int64,X0::Array{Float64,3})\n\nReturns a 3-d array to a matrix of genotype probabilities. size(X0)=(p,cross,n) –> (p1,n), where p1 = cross*p for p markers,  cross alleles or genotypes, and n individuals. See mat2array.\n\n\n\n\n\n","category":"method"},{"location":"functions/#FlxQTL.Util.getFinoidx-Tuple{Matrix{Union{Missing, Float64}}}","page":"Types and Functions","title":"FlxQTL.Util.getFinoidx","text":"getFinoidx(phenoData::Array{Union{Missing,Float64},2})\n\nAttains indices of phenotype data without missing values.\n\nArgument\n\nphenoData : A matrix of phenotype (or trait) data including missing values. size(phenoData) = (m,n) for m traits and n individuals.\n\n\n\n\n\n","category":"method"},{"location":"functions/#FlxQTL.Util.getGenoidx","page":"Types and Functions","title":"FlxQTL.Util.getGenoidx","text":"getGenoidx(GenoData::Union{Array{Any,2},Array{Float64,2}},maf::Float64=0.025)\n\nAttains genotype indices to drop correlated or bad markers.\n\nArguments\n\nGenoData : A matrix of genotype data. size(GenoData)= (p,n) for p markers and n individuals.\nmaf : A scalar for dropping criterion of markers. Default is 0.025 i.e. markers of MAF < 0.025 are dropped.\n\n\n\n\n\n","category":"function"},{"location":"functions/#FlxQTL.Util.lod2logP-Tuple{Union{Vector{Any}, Vector{Float64}}, Int64}","page":"Types and Functions","title":"FlxQTL.Util.lod2logP","text":"lod2logP(LODs::Union{Array{Float64,1},Array{Any,1}},v::Int64)\n\nCaculates -log_10P from LOD scores.\n\nArguments\n\nLODs : A vector of LOD scores computed from genome scan.\nv : Degrees of freedom for Chi-squared distribution.  \n\n!!! NOTE\n\nTo compute degrees of freedom for 1D-genome scan (geneScan), v = prod(size(B1))-prod(size(B0), where B1 and B0 are effect size matrices under H1 of a full model (intercept + covariates + QTL) and H0 of no QTL (intercept + covariates), respectively.\n\n\n\n\n\n","category":"method"},{"location":"functions/#FlxQTL.Util.mat2array-Tuple{Int64, Any}","page":"Types and Functions","title":"FlxQTL.Util.mat2array","text":" mat2array(cross::Int64,X0)\n\nReturns a matrix of genotype probabilities to 3-d array. size(X0)=(p1,n) –> (p,cross,n), where p1 = cross*p for p markers,  cross alleles or genotypes, and n individuals.\n\nArgument\n\ncross : An integer indicating the number of alleles or genotypes. Ex. 2 for RIF, 4 for four-way cross, 8 for HS mouse (allele probabilities), etc.\nX0 : A matrix of genotype probability data computed from r/qtl or r/qtl2.  \n\nSee array2mat.\n\n\n\n\n\n","category":"method"},{"location":"functions/#FlxQTL.Util.mat2vec-Tuple{Any}","page":"Types and Functions","title":"FlxQTL.Util.mat2vec","text":" mat2vec(mat)\n\nStacks a matrix to a vector, i.e. vectorizing a matrix.\n\n\n\n\n\n","category":"method"},{"location":"functions/#FlxQTL.Util.newMarkers","page":"Types and Functions","title":"FlxQTL.Util.newMarkers","text":"newMarkers(XX::Markers,cross::Int64,cM::Int64=2)\n\nReturns a struct of Markers by keeping only markers positioned in every cM centimorgans for 2-d genome scan to avoid singularity.\n\nArguments\n\nXX : A type of Markers. See Markers.\ncross : An integer indicating the number of alleles or genotypes. Ex. 2 for RIF, 4 for four-way cross, 8 for HS mouse (allele probabilities), etc.\ncM : An integer of dropping criterion of markers. Default is 2, i.e. keeping only markers in every 2 cM, or dropping markers within 2cM between 2 markers.\n\n\n\n\n\n","category":"function"},{"location":"functions/#FlxQTL.Util.ordrMarkers-Tuple{Matrix{Any}}","page":"Types and Functions","title":"FlxQTL.Util.ordrMarkers","text":"ordrMarkers(markers::Array{Any,2})\n\nRearrange by CPU parallelization marker information composed of marker name, chr, position obtained from rqtl2, which is not listed in order (excluding X chromosome).\n\nArgument\n\nmarkers : An array of marker information.\n\n\n\n\n\n","category":"method"},{"location":"functions/#FlxQTL.Util.setSeed","page":"Types and Functions","title":"FlxQTL.Util.setSeed","text":"setSeed(lw::Int64,up::Int64,replace::Bool=false)\n\nAssigns different numbers of seeds to workers (or processes).\n\nArguments\n\nlw : A lower bound to set seeds.\nup : A upper bound to set seeds.\nreplace : Sampling seed numbers between lw and up with/without replacement. Default is false: without replacement.          Since the function itself recognize the number of processes (or workers) and their id, a wider range of seed numbers needs to set for default.\n\nExamples\n\njulia> using Distributed\njulia> addprocs(10)\njulia> @everywhere using flxQTL\njulia> setSeed(1,20)\n\n\n\n\n\n\n","category":"function"},{"location":"functions/#FlxQTL.Util.sortBycM","page":"Types and Functions","title":"FlxQTL.Util.sortBycM","text":"    sortBycM(Chr::Any,XX::Markers,cross::Int64,cM::Int64=2)\n\nReturns marker indices in Chromosome Chr and the corresponding genotype probabilities keeping only markers positioned in every cM centimorgans  for 2-d genome scan to avoid singularity.\n\nArguments\n\nChr : A type of Any indicating a particular chromosome to sort markers out.\nXX : A type of Markers.\ncross : An integer indicating the number of alleles or genotypes. Ex. 2 for RIF, 4 for four-way cross, 8 for HS mouse (allele probabilities), etc.\ncM : An integer of dropping criterion of markers. Default is 2, i.e. keeping only markers in every 2 cM, or dropping markers within 2cM between 2 markers.\n\nSee also newMarkers\n\n\n\n\n\n","category":"function"},{"location":"guide/analysis/#QTL-analysis","page":"QTL Analysis","title":"QTL analysis","text":"","category":"section"},{"location":"guide/analysis/","page":"QTL Analysis","title":"QTL Analysis","text":"This section describes a step-by-step guide for QTL analysis.","category":"page"},{"location":"guide/analysis/#Input-data-file-format","page":"QTL Analysis","title":"Input data file format","text":"","category":"section"},{"location":"guide/analysis/","page":"QTL Analysis","title":"QTL Analysis","text":"The package FlxQTL does not require any particular data format.  Any file readable in Julia is fine, but the input should contain traits (or phenotypes), genotype (probability), marker information on marker names, chromosomes, and marker positions, and optionally climatic information.  All inputs are types of  Arrays in Julia and should have no missing values, i.e. imputation is required if missing values exist.","category":"page"},{"location":"guide/analysis/#Reading-the-data-files-and-processing-arrays","page":"QTL Analysis","title":"Reading the data files and processing arrays","text":"","category":"section"},{"location":"guide/analysis/","page":"QTL Analysis","title":"QTL Analysis","text":"Use any Julia package able to read data files (.txt, .csv, etc.).  Julia's built-in module DelimitedFiles supports read, and write files.  Let's try using an example dataset in FlxQTL. It is plant data: Arabidopsis thaliana in the data folder.  Detailed description on the data can be  referred to README in the folder.","category":"page"},{"location":"guide/analysis/","page":"QTL Analysis","title":"QTL Analysis","text":"using DelimitedFiles\n\npheno = readdlm(\"data/Arabidopsis_fitness.csv\",',';skipstart=1); # skip to read the first row (column names) to obtain a matrix only\n\ngeno = readdlm(\"data/Arabidopsis_genotypes.csv\",',';skipstart=1); \n\nmarkerinfo = readdlm(\"data/Arabidopsis_markerinfo_1d.csv\",',';skipstart=1);\n","category":"page"},{"location":"guide/analysis/","page":"QTL Analysis","title":"QTL Analysis","text":"For efficient computation, the normalization of matrices is necessary.  The phenotype matrix labelled as pheno here composes of wide range of values  from 1.774 to 34.133, so that it is better to narow the range of values in [0,1], [-1,1], or any narrower interval for easy computation.  Note that  the dimension of a phenotype matrix should be the number of traits x the number of individuals.","category":"page"},{"location":"guide/analysis/","page":"QTL Analysis","title":"QTL Analysis","text":"using Statistics, StatsBase\nY=convert(Array{Float64,2},pheno'); #convert from transposed one to a Float64 matrix\nYstd=(Y.-mean(Y,dims=2))./std(Y,dims=2); # sitewise normalization","category":"page"},{"location":"guide/analysis/","page":"QTL Analysis","title":"QTL Analysis","text":"!!! Note","category":"page"},{"location":"guide/analysis/","page":"QTL Analysis","title":"QTL Analysis","text":"If the data are skewed or have outliers, simple standadization may not resolve them.  You may use a Y_huber function to rescale the data to be less sensitve to outliers.","category":"page"},{"location":"guide/analysis/","page":"QTL Analysis","title":"QTL Analysis","text":"In the genotype data, 1, 2 indicate Italian, Swedish parents, respectively. You can rescale the genotypes for efficiency. ","category":"page"},{"location":"guide/analysis/","page":"QTL Analysis","title":"QTL Analysis","text":"geno[geno.==1.0].=0.0;geno[geno.==2.0].=1.0; # or can do geno[geno.==1.0].=-1.0 for only genome scan\n","category":"page"},{"location":"guide/analysis/","page":"QTL Analysis","title":"QTL Analysis","text":"For genome scan, we need restructure the standardized genotype matrix combined with marker information.  Note that the genome scan in FlxQTL is  implemented by CPU parallelization, so we need to add workers (or processes) before the genome scan.  Depending on the computer CPU, one can add as many  processes as possible. If your computer has 16 cores, then you can add 15 or little more.  Note that you need to type @everywhere followed by using PackageName for parallel computing.  The dimension of a genotype (probability) matrix should be  the number of markers x the number of individuals.","category":"page"},{"location":"guide/analysis/","page":"QTL Analysis","title":"QTL Analysis","text":"using Distributed\naddprocs(4) \n@everywhere using FlxQTL \nXX=FlxQTL.Markers(markerinfo[:,1],markerinfo[:,2],markerinfo[:,3],geno') # marker names, chromosomes, marker positions, genotypes\n","category":"page"},{"location":"guide/analysis/","page":"QTL Analysis","title":"QTL Analysis","text":"Julia tip: Whenever you reload a package, i.e. using FlxQTL, you should re-enter XX=FlxQTL.Markers(markerinfo[:,1],markerinfo[:,2],markerinfo[:,3],geno') to fresh the struct of array.  If not, your genome scan throws an error.  You should also do with another struct of array in a submodule QTLplot, FlxQTL.layers.","category":"page"},{"location":"guide/analysis/","page":"QTL Analysis","title":"QTL Analysis","text":"Optionally, one can generate a trait covariate matrix (Z).  The first column indicates overall mean between the two regions, and  the second implies site difference: -1 for Italy, and 1 for Sweden.","category":"page"},{"location":"guide/analysis/","page":"QTL Analysis","title":"QTL Analysis","text":"Z=hcat(ones(6),vcat(-ones(3),ones(3)))\nm,q = size(Z) # check the dimension","category":"page"},{"location":"guide/analysis/#Computing-a-genetic-(or-climatic)-relatedness-matrix","page":"QTL Analysis","title":"Computing a genetic (or climatic) relatedness matrix","text":"","category":"section"},{"location":"guide/analysis/","page":"QTL Analysis","title":"QTL Analysis","text":"The submodule GRM contains functions for computing kinship matrices, kinshipMan, kinship4way, kinshipGs, kinshipLin, kinshipCtr, and computing  3D array of kinship matrices for LOCO (Leave One Chromosome Out) with a shrinkage method for nonpositive definiteness,  shrinkg, shrinkgLoco, kinshipLoco.   Note that the shrinkage option is only used for kinshipMan, kinship4way.","category":"page"},{"location":"guide/analysis/","page":"QTL Analysis","title":"QTL Analysis","text":"For the Arabidopsis genotype data, we will use a genetic relatedness matrix using manhattan distance measure, kinshipMan with a shrinkage with  the LOCO option.","category":"page"},{"location":"guide/analysis/","page":"QTL Analysis","title":"QTL Analysis","text":"Kg = FlxQTL.shrinkgLoco(FlxQTL.kinshipMan,10,XX)","category":"page"},{"location":"guide/analysis/","page":"QTL Analysis","title":"QTL Analysis","text":"For no LOCO option with shrinkage,","category":"page"},{"location":"guide/analysis/","page":"QTL Analysis","title":"QTL Analysis","text":"K = FlxQTL.shrinkg(FlxQTL.kinshipMan,10,XX.X)","category":"page"},{"location":"guide/analysis/","page":"QTL Analysis","title":"QTL Analysis","text":"If you have climatic information on your trait data, you can compute the relatedness matrix using one of the above functions, but it is recommended using  kinshipGs,kinshipLin,kinshipCtr after normalization.  Since the climatic information is not available, we use an identity matrix.","category":"page"},{"location":"guide/analysis/","page":"QTL Analysis","title":"QTL Analysis","text":"using LinearAlgebra\nKc = Matrix(1.0I,6,6) # 3 years x 2 sites","category":"page"},{"location":"guide/analysis/#D-genome-scan","page":"QTL Analysis","title":"1D genome scan","text":"","category":"section"},{"location":"guide/analysis/","page":"QTL Analysis","title":"QTL Analysis","text":"Once all input matrices are ready, we need to proceed the eigen-decomposition to two relatedness matrices.  For a non-identity climatic relatedness, and a kinship with LOCO, you can do eigen-decomposition simultaneously.  Since we use the identity climatic  relatedness, you can use Matrix(1.0I,6,6) for a matrix of eigenvectors and ones(6) for a vector of eigenvalues.","category":"page"},{"location":"guide/analysis/","page":"QTL Analysis","title":"QTL Analysis","text":"Tg,Λg,Tc,λc = FlxQTL.K2Eig(Kg,Kc,true); # the last argument: LOCO::Bool = false (default)\n\nTg,λg = FlxQTL.K2eig(Kg, true) # for eigen decomposition to one kinship with LOCO","category":"page"},{"location":"guide/analysis/","page":"QTL Analysis","title":"QTL Analysis","text":"For eigen decomposition to one kinship with no LOCO option,","category":"page"},{"location":"guide/analysis/","page":"QTL Analysis","title":"QTL Analysis","text":"T,λ = FlxQTL.K2eig(K)","category":"page"},{"location":"guide/analysis/","page":"QTL Analysis","title":"QTL Analysis","text":"Now start with 1D genome scan with (or without) LOCO including Z or not.   For the genome scan with LOCO including Z, ","category":"page"},{"location":"guide/analysis/","page":"QTL Analysis","title":"QTL Analysis","text":"LODs,B,est0 = FlxQTL.geneScan(1,Tg,Tc,Λg,λc,Ystd,XX,Z,true); # FlxQTL for including Z (trait covariates) or Z=I","category":"page"},{"location":"guide/analysis/","page":"QTL Analysis","title":"QTL Analysis","text":"For the genome scan with LOCO excluding Z, i.e. an identity matrix, we have two options: a FlxQTL model and a conventional MLMM ","category":"page"},{"location":"guide/analysis/","page":"QTL Analysis","title":"QTL Analysis","text":"LODs,B,est0 = FlxQTL.geneScan(1,Tg,Tc,Λg,λc,Ystd,XX,true); # FlxQTL for Z=I \n\nLODs,B,est0 =FlxQTL.geneScan(1,Tg,Λg,Ystd,XX,true); # MLMM","category":"page"},{"location":"guide/analysis/","page":"QTL Analysis","title":"QTL Analysis","text":"Note that the first argument in geneScan is cross::Int64, which indicates a type of genotype or genotype probability.  For instance, if you use a  genotype matrix whose entry is one of 0,1,2, type 1. If you use genotype probability matrices, depending on the number of alleles or genotypes in a marker, one can type the corresponding number. i.e. 4-way cross: 4, HS DO mouse: 8 for alleles, 32 for genotypes, etc.   ","category":"page"},{"location":"guide/analysis/","page":"QTL Analysis","title":"QTL Analysis","text":"For no LOCO option,","category":"page"},{"location":"guide/analysis/","page":"QTL Analysis","title":"QTL Analysis","text":"LODs,B,est0 = FlxQTL.geneScan(1,T,Tc,λ,λc,Ystd,XX,Z);\n\nLODs,B,est0 = FlxQTL.geneScan(1,T,Tc,λ,λc,Ystd,XX);\n\nLODs,B,est0 =FlxQTL.geneScan(1,T,λ,Ystd,XX); # MLMM","category":"page"},{"location":"guide/analysis/","page":"QTL Analysis","title":"QTL Analysis","text":"The function geneScan has three arguments: LOD scores (LODs), effects matrix under H1 (B), and parameter estimates under H0 (est0), which  is an Array{Any,1}.  If you want to see null parameter esitmate in chromosome 1 for LOCO option, type est0[1].B, est0[1].loglik, est0[1].τ2,  est0[1].Σ.    In particular, you can extract values from each matrix in B (3D array of matrices) to generate an effects plot. To print an effect size matrix for the  third marker, type B[:,:,3].","category":"page"},{"location":"guide/analysis/#Generating-plots","page":"QTL Analysis","title":"Generating plots","text":"","category":"section"},{"location":"guide/analysis/","page":"QTL Analysis","title":"QTL Analysis","text":"To produce a plot (or plots) for LOD scores or effects, you need first a struct of arrays, layers consisting of chromosomes, marker positions,  LOD scores (or effects), which should be Array{Float64,2}.  You can then generate one genome scan result or multiple genenome scan results on one plot.  Note that the color is randomly selected to generate a plot.    The function plot1d has more keyword argument options: yint=[] for a vector of y-intercept(s), yint_color=[\"red\"] for a vector of y-intercept  color(s), Legend=[] for multiple graphs, loc=\"upper right\" for the location of Legend, etc.","category":"page"},{"location":"guide/analysis/","page":"QTL Analysis","title":"QTL Analysis","text":"Arab_lod = FlxQTL.layers(markerinfo[:,2],markerinfo[:,3],LODs[:,:]) # LODs is a vector here, so force it to be a matrix\nplot1d(Arab_lod;title= \"LOD for Arabidopsis thaliana : Fitness (2 site by 3 year, 6 traits)\",ylabel=\"LOD\")","category":"page"},{"location":"guide/analysis/","page":"QTL Analysis","title":"QTL Analysis","text":"(Image: arabidopsis)","category":"page"},{"location":"guide/analysis/#Performing-a-permutation-test","page":"QTL Analysis","title":"Performing a permutation test","text":"","category":"section"},{"location":"guide/analysis/","page":"QTL Analysis","title":"QTL Analysis","text":"Since the statistical inference for FlxQTL relies on LOD scores and LOD scores, the function permTest finds thresholds for a type I error.  The first  argument is nperm::Int64 to set the number of permutations for the test. For Z = I, type Matrix(1.0I,6,6) for the Arabidopsis thaliana data.  In the keyword argument, pval=[0.05 0.01] is default to get thresholds of type I error rates (α).  Note that permutation test is implemented by no LOCO option.","category":"page"},{"location":"guide/analysis/","page":"QTL Analysis","title":"QTL Analysis","text":"julia> maxLODs, H1par_perm, cutoff = FlxQTL.permTest(1000,1,K,Kc,Ystd,XX,Z;pval=[0.05]) # cutoff at 5 %","category":"page"},{"location":"#FlxQTL.jl","page":"Home","title":"FlxQTL.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A package for a Flexible multivariate linear mixed model (MLMM) suitable for QTL (Quantitative Trait Loci) analysis of structured multivariate traits. ","category":"page"},{"location":"#Package-Features","page":"Home","title":"Package Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Genome scan (1D, 2D) for univariate, multivariate trait(s), and genotype (probability) data\nLOCO (Leave One Chromosome Out) support for genome scan \nVisualization (1D, 2D plots)\nComputation for Genetic (or Climatic) Relatedness matrix (or kinship) \nCPU parallelization","category":"page"},{"location":"#Guide","page":"Home","title":"Guide","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"guide/tutorial.md\",\n        \"guide/analysis.md\",   \n        ]\nDepth = 1\n","category":"page"},{"location":"#Manual","page":"Home","title":"Manual","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The descriptions of functions and types arranged by module.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"functions.md\"]\n","category":"page"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"functions.md\"]","category":"page"},{"location":"guide/tutorial/#Package-Guide","page":"Package Guide","title":"Package Guide","text":"","category":"section"},{"location":"guide/tutorial/#Installation","page":"Package Guide","title":"Installation","text":"","category":"section"},{"location":"guide/tutorial/","page":"Package Guide","title":"Package Guide","text":"The package can installed in following ways. In a Julia REPL, press ] to enter a package mode,","category":"page"},{"location":"guide/tutorial/","page":"Package Guide","title":"Package Guide","text":"pkg> add FlxQTL","category":"page"},{"location":"guide/tutorial/","page":"Package Guide","title":"Package Guide","text":"Or, equivalently, ","category":"page"},{"location":"guide/tutorial/","page":"Package Guide","title":"Package Guide","text":"julia> using Pkg; Pkg.add(\"FlxQTL\")","category":"page"},{"location":"guide/tutorial/","page":"Package Guide","title":"Package Guide","text":"Currently Julia 1.5 supports for the package.","category":"page"},{"location":"guide/tutorial/","page":"Package Guide","title":"Package Guide","text":"To remove the package from the Julia REPL,","category":"page"},{"location":"guide/tutorial/","page":"Package Guide","title":"Package Guide","text":"pkg> rm FlxQTL","category":"page"},{"location":"guide/tutorial/","page":"Package Guide","title":"Package Guide","text":"Equivalently,","category":"page"},{"location":"guide/tutorial/","page":"Package Guide","title":"Package Guide","text":"julia> using Pkg; Pkg.rm(\"FlxQTL\")","category":"page"},{"location":"guide/tutorial/#Choice-of-BLAS-vendors","page":"Package Guide","title":"Choice of BLAS vendors","text":"","category":"section"},{"location":"guide/tutorial/","page":"Package Guide","title":"Package Guide","text":"The package can be run in either openblas (built-in Julia dense linear algebra routines) or MKL (intel MKL linear algebra).   Without the intel MKL hardware, the installation of MKL.jl in Julia can slightly improve the performance.   For its installation, consult with MKL.jl.","category":"page"}]
}
